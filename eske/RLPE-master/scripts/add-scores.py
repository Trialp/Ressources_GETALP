#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from __future__ import division
import sys
from itertools import groupby
from os.path import dirname, realpath
# allows imports from parent directory
sys.path.append(dirname(dirname(realpath(__file__))))
from tercom import tercom_scores

if __name__ == '__main__':
    """
    Computes TER score of states in trajectories. Takes a trajectory file as generated by trajectories.py
    and prints entries of the form:
        idx src state1 state2 action TER(state1, ref) TER(state2, ref)      (separated by '|||')

    Example usage:
        ./add-scores.py < data/trajectories.txt > data/trajectories_with_score.txt
    """

    data = []

    # group transitions by their index (which indicates the trajectory they belong to)
    for group in groupby(sys.stdin, key=lambda line: line.split('|||', 1)[0]):
        transitions = []
        for line in group[1]:
            idx, src, trg1, trg2, action = line.strip().split('|||')
            transitions.append(line.strip().split('|||'))

        reference = transitions[-1][3]
        for idx, src, trg1, trg2, action in transitions:
            data.append((idx, src, trg1, trg2, action, reference))

        data.append((idx, src, trg2, None, None, reference))  # add empty transition at the end

    # compute the TER score only once for each state (for each starting state of each transition, as the
    # arrival state is the starting state of the next transition).
    # The empty transition at the end ensures that the last state of the trajectory is not missed.
    hypotheses, references = zip(*[(trg1, reference) for _, _, trg1, _, _, reference in data])
    scores = tercom_scores(hypotheses, references)

    for i, (idx, src, trg1, trg2, action, _) in enumerate(data):
        # don't print empty transition
        if trg2 is None:
            continue
        print '|||'.join(map(str, [idx, src, trg1, trg2, action, 1 - scores[i], 1 - scores[i + 1]]))
